"""Classes for storing firewall rules."""

from collections.abc import Callable
from ipaddress import IPv4Address
from ipaddress import IPv4Network
from typing import Annotated
from typing import Any
from typing import Literal

from annotated_types import Len
from pydantic import BaseModel
from pydantic import computed_field
from pydantic import Field
from pydantic import field_validator
from pydantic import RootModel
from pydantic import SerializationInfo
from pydantic import ValidationInfo
from pydantic import WrapSerializer

from net_configurator.namer import Namer


class IdentifiedBaseModel(BaseModel):
    """BaseModel with added autogenerated identifier attribute."""

    @computed_field  # type: ignore[prop-decorator]
    @property
    def identifier(self) -> str:
        """Returns model's identifier."""
        return Namer.generate_identifier(self.model_dump_json(exclude={'identifier'}))


def sort_before_serialization(value: list[BaseModel], handler: Callable[[list[BaseModel], SerializationInfo], Any], info: SerializationInfo) -> Any:
    """Sorts list of BaseModel before serialization."""
    sorted_value = sorted(value, key=BaseModel.model_dump_json)
    return handler(sorted_value, info)


class NetworkService(BaseModel, frozen=True):
    """A protocol with (optionally) a port or a port range.

    Attributes:
        protocol (str): the protocol.
        port_low (int, optional): Port number or a low end of port range.
        port_high (int, optional): How end of port range.

    Raises:
        ValidationError: When data violates restrictions.
    """

    protocol: Literal['tcp', 'udp', 'icmp']
    port_low: Annotated[int | None, Field(ge=0, le=65535)] = Field(default=None, validate_default=True)
    port_high: Annotated[int | None, Field(ge=0, le=65535)] = Field(default=None, validate_default=True)

    @field_validator('port_low', mode='after')
    @classmethod
    def tcpudp_has_port_low(cls, value: int | None, info: ValidationInfo) -> int | None:
        """Verifies port is specified for transport protocols and deletes for ICMP."""
        if info.data.get('protocol') == 'icmp':
            value = None
        elif value is None:
            msg = 'TCP/UDP requires a port number'
            raise ValueError(msg)
        return value

    @field_validator('port_high', mode='after')
    @classmethod
    def port_high_ge_low(cls, value: int | None, info: ValidationInfo) -> int | None:
        """Verifies port ranges and deletes port_high for non-ranges."""
        port_low = info.data.get('port_low')
        if port_low is None or value is None or value == port_low:
            value = None
        else:
            if value < port_low:
                msg = 'port_high cannot be lower than port_low'
                raise ValueError(msg)
            if port_low == 0:
                msg = 'Port 0 cannot be used in ranges'
                raise ValueError(msg)
        return value


class RuleFilter(RootModel[list[NetworkService]], IdentifiedBaseModel):
    """List of NetworkService with autogenerated identifier attribute.

    Filter's elements are sorted before serialization to ensure repeatable identifiers.
    """

    root: Annotated[list[NetworkService], Len(min_length=1), WrapSerializer(sort_before_serialization)]


class NetworkPeer(BaseModel):
    """Single IP address or range or network.

    Attributes:
        ip_low (IPv4Address | IPv4Network): Single or net IP or low end of range.
        ip_high (IPv4Address): How end of IP range.

    Raises:
        ValidationError: When data violates restrictions.
    """

    ip_low: IPv4Address | IPv4Network
    ip_high: IPv4Address | None = None

    @field_validator('ip_high', mode='after')
    @classmethod
    def ip_high_ge_low(cls, value: IPv4Address, info: ValidationInfo) -> IPv4Address | None:
        """Verifies IP ranges."""
        return_value: IPv4Address | None = value
        if value is not None:
            ip_low: IPv4Address | IPv4Network = info.data.get('ip_low')  # type: ignore[assignment]
            if isinstance(ip_low, IPv4Network):
                msg = 'Range is not possible when ip_low is network address'
                raise ValueError(msg)
            if value < ip_low:
                msg = 'ip_high cannot be lower than ip_low'
                raise ValueError(msg)
            if value == ip_low:
                return_value = None
        return return_value


class Rule(IdentifiedBaseModel):
    """A firewall rule with autogenerated identifier attribute.

    Rule's elements are sorted before serialization to ensure repeatable identifiers.

    Attributes:
        sources (list[NetworkPeer]): List of source IP addresses.
        destinations (list[NetworkPeer]): List of destination IP addresses.
        filter (RuleFilter): List of sockets.
        owners (set[str]): Owner tags.

    Raises:
        ValidationError: If data violates restrictions.
    """

    sources: Annotated[list[NetworkPeer], Len(min_length=1), WrapSerializer(sort_before_serialization)]
    destinations: Annotated[list[NetworkPeer], Len(min_length=1), WrapSerializer(sort_before_serialization)]
    filter: RuleFilter
    owners: set[str] = set()
