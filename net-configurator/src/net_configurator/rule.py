"""Classes for storing firewall rules."""

from ipaddress import IPv4Address
from ipaddress import IPv4Network
from typing import Annotated
from typing import Any
from typing import cast
from typing import Literal
from typing import Protocol

from annotated_types import Len
from pydantic import BaseModel
from pydantic import computed_field
from pydantic import Field
from pydantic import field_validator
from pydantic import RootModel
from pydantic import StringConstraints
from pydantic import ValidationInfo

from net_configurator.namer import Namer


class IdentifiedModelInterface(Protocol):
    """Interface with attribute 'identifier'."""

    @property
    def identifier(self) -> str:
        """Returns object's identifier."""
        ...


class IdentifiedBaseModel(BaseModel):
    """BaseModel with added autogenerated identifier attribute."""

    @computed_field  # type: ignore[prop-decorator]
    @property
    def identifier(self) -> str:
        """Returns model's identifier."""
        return Namer.generate_identifier(self.model_dump_json(exclude={'identifier'}))

    @classmethod
    def sort_unique(cls, value: tuple[BaseModel, ...]) -> tuple[BaseModel, ...]:
        """Returns argument as sorted tuple of unique elements."""
        return tuple(sorted(set(value), key=lambda service: service.model_dump_json()))


class NetworkService(BaseModel, frozen=True):
    """A protocol with (optionally) a port or a port range.

    Attributes:
        protocol (str): the protocol.
        port_low (int, optional): Port number or a low end of port range.
        port_high (int, optional): How end of port range.

    Raises:
        ValidationError: When data violates restrictions.
    """

    protocol: Literal['tcp', 'udp', 'icmp']
    port_low: Annotated[int | None, Field(ge=0, le=65535)] = Field(default=None, validate_default=True)
    port_high: Annotated[int | None, Field(ge=0, le=65535)] = Field(default=None, validate_default=True)

    @field_validator('port_low', mode='after')
    @classmethod
    def tcpudp_has_port_low(cls, value: int | None, info: ValidationInfo) -> int | None:
        """Verifies port is specified for transport protocols and deletes for ICMP."""
        protocol: str = cast(str, info.data.get('protocol'))
        if protocol == 'icmp':
            value = None
        elif (protocol in {'tcp', 'udp'}) and value is None:
            msg = 'TCP/UDP requires a port number'
            raise ValueError(msg)
        return value

    @field_validator('port_high', mode='after')
    @classmethod
    def port_high_ge_low(cls, value: int | None, info: ValidationInfo) -> int | None:
        """Verifies port ranges and deletes port_high for non-ranges."""
        port_low = info.data.get('port_low')
        if port_low is None or value is None or value == port_low:
            value = None
        else:
            if value < port_low:
                msg = 'port_high cannot be lower than port_low'
                raise ValueError(msg)
            if port_low == 0:
                msg = 'Port 0 cannot be used in ranges'
                raise ValueError(msg)
        return value

    def has_port(self) -> bool:
        """Returns True when NetworkService has port(s) specified."""
        return self.port_low is not None

    def is_port_single(self) -> bool:
        """Returns True when NetworkService has single port."""
        return self.has_port() and self.port_high is None

    def is_port_range(self) -> bool:
        """Returns True when NetworkService has range of ports."""
        return self.has_port() and self.port_high is not None


class PacketFilter(IdentifiedBaseModel, frozen=True):
    """List of NetworkService with autogenerated identifier attribute.

    Filter's elements are unique and sorted to ensure repeatable identifiers.

    Attributes:
        services (tuple[NetworkService]): Network services.

    Raises:
        ValidationError: When data violates restrictions.
    """

    services: Annotated[tuple[NetworkService, ...], Len(min_length=1)]

    @field_validator('services', mode='after')
    @classmethod
    def services_are_unique_and_sorted(cls, value: tuple[NetworkService, ...]) -> tuple[NetworkService, ...]:
        """Ensures services are unique and sorted."""
        return cast(tuple[NetworkService, ...], PacketFilter.sort_unique(value))


class NetworkPeer(BaseModel, frozen=True):
    """Single IP address or range or network.

    Attributes:
        ip_low (IPv4Address | IPv4Network): Single or net IP or low end of range.
        ip_high (IPv4Address): How end of IP range.

    Raises:
        ValidationError: When data violates restrictions.
    """

    ip_low: IPv4Address | IPv4Network
    ip_high: IPv4Address | None = None

    @field_validator('ip_high', mode='after')
    @classmethod
    def ip_high_ge_low(cls, value: IPv4Address, info: ValidationInfo) -> IPv4Address | None:
        """Verifies IP ranges."""
        return_value: IPv4Address | None = value
        if value is not None:
            ip_low: IPv4Address | IPv4Network = info.data.get('ip_low')  # type: ignore[assignment]
            if isinstance(ip_low, IPv4Network):
                msg = 'Range is not possible when ip_low is network address'
                raise ValueError(msg)
            if value < ip_low:
                msg = 'ip_high cannot be lower than ip_low'
                raise ValueError(msg)
            if value == ip_low:
                return_value = None
        return return_value

    def is_address_network(self) -> bool:
        """Returns True when NetworkPeer is network address."""
        return isinstance(self.ip_low, IPv4Network)

    def is_address_single(self) -> bool:
        """Returns True when NetworkPeer is single IP address."""
        return not self.is_address_network() and self.ip_high is None

    def is_address_range(self) -> bool:
        """Returns True when NetworkPeer is range of addresses."""
        return not self.is_address_network() and self.ip_high is not None


class Owner(RootModel[str], frozen=True):
    """Single owner of a rule.

    Raises:
        ValidationError: When data violates restrictions.
    """

    root: Annotated[str, StringConstraints(pattern=Namer.get_owner_pattern())]

    @computed_field  # type: ignore[prop-decorator]
    @property
    def identifier(self) -> str:
        """Returns model's identifier."""
        return self.root

    def __lt__(self, other: RootModel[str]) -> bool:
        """Returns self < other for sorting."""
        return self.root < other.root

    def __le__(self, other: RootModel[str]) -> bool:
        """Returns self <= other for sorting."""
        return self.root <= other.root

    def __gt__(self, other: RootModel[str]) -> bool:
        """Returns self > other for sorting."""
        return self.root > other.root

    def __ge__(self, other: RootModel[str]) -> bool:
        """Returns self >= other for sorting."""
        return self.root >= other.root


class Rule(IdentifiedBaseModel, frozen=True):
    """A firewall rule with autogenerated identifier attribute.

    Rule's elements are unique and sorted to ensure repeatable identifiers.

    Attributes:
        sources (tuple[NetworkPeer]): Source IP addresses.
        destinations (tuple[NetworkPeer]): Destination IP addresses.
        packet_filter (PacketFilter): Sockets.
        owners (tuple[str]): Owner tags.

    Raises:
        ValidationError: If data violates restrictions.
    """

    sources: Annotated[tuple[NetworkPeer, ...], Len(min_length=1)]
    destinations: Annotated[tuple[NetworkPeer, ...], Len(min_length=1)]
    packet_filter: PacketFilter
    owners: tuple[Owner, ...] = ()

    @field_validator('sources', 'destinations', mode='after')
    @classmethod
    def addresses_are_unique_and_sorted(cls, value: tuple[NetworkPeer, ...]) -> tuple[NetworkPeer, ...]:
        """Ensures addresses are unique and sorted."""
        return cast(tuple[NetworkPeer, ...], Rule.sort_unique(value))

    @field_validator('owners', mode='before')
    @classmethod
    def owners_none_to_tuple(cls, value: Any) -> Any:
        """None value for owners is convertet to empty tuple."""
        if value is None:
            return ()
        return value

    @field_validator('owners', mode='after')
    @classmethod
    def owners_are_unique_and_sorted(cls, value: tuple[Owner, ...]) -> tuple[Owner, ...]:
        """Ensures addresses are unique and sorted."""
        if value is None:
            return None
        return tuple(sorted(set(value)))
